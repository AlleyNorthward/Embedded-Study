# 简介
理解远大于背过

[原理](#原理)
[部分代码分析](#部分代码分析)
[实现代码分析](#实现代码分析)


## 原理
- 目前用的`usart1`接口是双向通信,能收能发.
- 对于`usart`,它主要完成两件事情,第一就是将我们要发送的字节数据,转换成电平波形,比如`01010110`.第二则是将从引脚上收到的波形,还原成字节数据.
- 本质上,`usart`硬件就是帮我们完成了所有的`0/1`的时间控制,位对齐,起止位识别等麻烦事.
- `usart`采用的是异步通信.那么异步通信是什么呢?
    - 收发双方没有"时钟线"(即频率不一致)
    - 收发双方各用自己的系统时钟.
    - 收发双方约定好比特率(`bit`发送频率一致)
    - 收发双方将每个字符的传输格式约定好:"起始位+数据位+停止位(+可选校验位)"
    - 这样,接收端在检测到起始位(电平由高->低)后,就开始用自己的时钟按位采样,恢复出每个`bit`.
    - 异步通信靠波特率一致来保持同步
- `usart1`是全双工接口(`TX`,`RX`各一根线,可以同时双向通信).那么TX`和`RX`是什么呢?
    - `Rx`是接受功能,`Tx`是发送功能.
    - `usart`模式可以用仅接收(`USART_Mode_Rx`),仅发送(`USART_Mode_Tx`),同时收发(`USART_Mode_Rx|USART_Mode_Tx`)
- 收发的底层逻辑,也很简单.
    - 比如,电脑通过串口发送一串字节(`123456\n`),其实就是按照波特率发送一串电平波形(高低电平)
    - `Rx`引脚检测草起始位电平时,`usart`硬件开始计时,按照波特率自动采样,会付出每个`bit`.
    - 每组装完一个字节后(比如上述字节流`1`),就会将其放入接受寄存器`RDR`中,硬件自动置位`RXNE`标志(表示"接收数据寄存器非空").
    - 本来到此其实就结束了.可是如果此时正好接受中断,那么就会进入中断函数中,产生对应功能(比如读取数据寄存器中存入的值,并放入缓冲器中)
    - 之后,在主循环或者发送函数里,我们使用`usart`的发送功能,我们会选择缓冲器中存储好的数据(这个缓冲器就是一个数组,软件端的,用来存储我们向`cpu`发送的数据信息),然后会将缓冲信息写入发送寄存器`TDR`中,`usart`硬件便开始自动将缓冲信息按位发送出去(在`Tx`引脚输出电平序列)
    - 当所有`bit`位都发送完了,`TC`标志位置`1`
    - 每当发现标志位置`1`(也就是`while(USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET)`)时,会继续发下一个字节,最后串口助手就收到了完整的字符串.
- 上面说的收发逻辑,不算错,但仍然不够细致.下面再来分析一下.
    - 注意,所谓的收发数据,并不是在代码之中的.上面有些混乱了.
    - 收发数据,是通过电脑端的串口助手帮助实现的.在上面输入数据,点击发送,则电脑通过`Tx`端,像`usart`的`Rx`端发送这串数据.
    - 串口助手上面显示的,则是`usart`的`Tx`端,像电脑的`Rx`端发送数据,并在电脑上显示.
    - 收发数据的两端,是两台独立的设备(电脑和`MCU`).而程序则是用来驱动`MCU`的,程序中不会有我们要收发的数据.
    - 两个设备通过电平信号交流,具体逻辑可以看看上面.
    - 电脑端发送字符`A`,串口芯片(比如`CH340`)会将`A`编码成`起始位(0) + 01000001 + 停止位(1)`,  并以一定的波特率,输出到`Tx`引脚.
    - 然后`MCU`的`usart`的`Rx`引脚检测到起始位电平由高到低(起始位)
    - `usart`硬件自动开始计时,采样,恢复出每一位,最终组合出一个字节`0x41`,并存入到`RDR`中.
    - 且硬件端自动置位`RXNE`,表示接受不为空.
    - 此时,`cpu`并没有参与,一切都是硬件自动完成的.
    - 如果开启中断(比如`RXNE=1`会触发中断)
    - 此时`cpu`会读取`RDR`寄存器的内容,并存储到软件缓冲区(数组中)
    - 这样,电脑端发的字节,被`MCU`的程序拿到了.
    - 所以,仍是`MCU`接收一个字节后发生一次中断,将信息存储到寄存器中,最后收到停止位后,停止接收.
    - `MCU`发送数据时,会将缓存区信息写入发送寄存器`TDR`中,然后由`usart`硬件自动发送:将`TDR`内容转为波形,发完所有位后,置位`TC`,并发送下一个字节.
    - 电脑端串口助手也会从它的`Rx`引脚检测电平,恢复对应字节.
- `usart`的仅发送,比如温度传感器定时输出温度,仅接收,比如串口`GPS`模块,双向通信,比如电脑发送指令,`MCU`返回结果.

## 部分代码分析
- 对于`Tx Rx`,二者是需要输出输入的,所以也需要`GPIO`引脚的.既然有引脚,也就有时钟使能和`GPIO`初始化.选择的模式是分别是复用推挽输出(`GPIO_Mode_AF_PP`)以及浮空输入(`GPIO_Mode_IN_FLOATING`).为什么呢?
    - `AF`,英文全称`Alternate Function`,含义是,这个引脚不再由普通的`GPIO`控制了(不是`GPIO_SetBits` `GPIO_ResetBits`控制),而是交给其他外设(`Alternate Function`)来控制输出信号.
    - 在这里,也就是说,电平是由`USART`硬件外设自动控制的(也就是字节流电平信号),而不是再由`GPIO`单独地输出高电平或低电平了.
    - 关于推挽输出,这里就不再多说了.
    - 浮空输入呢,也是很好理解的.原本高低电平的抽象,是由`GPIO`内部的上拉(高电平)或者下拉(低电平)抽象出来的(比如按键`key`,这里不再细致描述了,前面`key`强调过很多次了)
    - 而如今, 输入端是电脑,电脑将端的`Tx`将信息转换成数字信号了,然后`MCU`的`Rx`可以直接接收数字信号.数字信号有高电平,有低电平,不再需要上拉电阻或下拉电阻了,只需要浮空模式,单纯地接收数字信号即可.
- 关于`usart`的初始化配置,想了想,还是直接将`Ai`内容贴过来吧,看看就行,不好总结.
~~~C
USART_InitStructure.USART_BaudRate = baud_rate;
USART_InitStructure.USART_WordLength = USART_WordLength_8b;
USART_InitStructure.USART_StopBits = USART_StopBits_1;
USART_InitStructure.USART_Parity = USART_Parity_No;
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
USART_Init(USART1, &USART_InitStructure);
~~~
很好——你的那段“部分代码分析”已经很接近工程上正确的描述了。下面我把两部分内容分开、逐项梳理并补充细节（包括寄存器层面的对应、可能的注意点以及常见误区），让你从源码→库函数→寄存器→电平/时序 都能一条线串起。

---

# 一、你那段话核对与补充（关于 AF_PP / IN_FLOATING）

结论：**总体正确**，只需补充两点小细节。

* `GPIO_Mode_AF_PP`（复用 推挽 输出）
  * 正确含义：把引脚“交给外设（USART）”来控制输出电平（`AF`），由外设在发送数据时自动产生高/低电平波形；`PP` 表示推挽驱动，能主动把线拉高也能主动把线拉低，提供较强驱动，适合高速数字信号（例如 TX）。
  * 该输出就是 **MCU → 外部（如电脑或 USB-串口芯片）的 TX**。
  * 说明：如果把 TX 配成普通 GPIO（非 AF），USART 发数据时引脚不会由外设控制，通信会失败。
  
* `GPIO_Mode_IN_FLOATING`（浮空输入）

  * 正确含义：RX 由外部设备（电脑侧的串口驱动芯片）主动驱动，因此内部不启用上拉或下拉，避免干扰外部驱动；引脚只是“被动读取”外部电平。
  * 补充：**前提**是外部总是有驱动器把线拉到定义的空闲电平（UART 空闲通常是高电平）。如果外部可能断开（线悬空），为了避免噪声误触发，可以在硬件/软件上考虑上拉；但常见的 USB-串口芯片会可靠地把线置为高电平，所以浮空通常没问题。

---

# 二、`USART_InitStructure` 每个字段到底是什么意思（带底层寄存器／行为说明）

下面我把每个字段一一讲清、并说明库函数最终是怎么控制硬件寄存器的（STM32F1 的寄存器位置/含义概览）。

```c
USART_InitStructure.USART_BaudRate = baud_rate;
USART_InitStructure.USART_WordLength = USART_WordLength_8b;
USART_InitStructure.USART_StopBits = USART_StopBits_1;
USART_InitStructure.USART_Parity = USART_Parity_No;
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
USART_Init(USART1, &USART_InitStructure);
```

### 1) `USART_BaudRate`（波特率）

* 含义：发送/接收时每比特的速率（bps），如 9600、115200。
* 硬件上：库会根据 `USARTx` 的时钟频率 `fCK`（USART1 在 APB2）算出 `USARTDIV`，并把结果写入波特率寄存器 `USART_BRR`。
* 公式（STM32F1, oversampling by 16）大致为：
  [
  USARTDIV = \frac{f_{CK}}{16 \cdot Baud}
  ]
  `BRR` 的整数/小数部分按固定位宽编码到寄存器。
* 示例：若 `fCK = 72\,MHz` 且 `Baud = 115200`，那么 `USARTDIV ≈ 72e6/(16*115200) = 39.0625`（注意不同手册表达方式，常见实现会处理成整数与分数部分写入 BRR）。（库函数会完成计算并设置好 BRR。）

> 注意：APB 分频、PLL 设置会影响 `fCK`，所以实际 BRR 值依赖系统时钟配置。

### 2) `USART_WordLength`（数据位长度）

* 选项通常是 8 位或 9 位（`M` 位控制，寄存器 `USART_CR1.M`）。
* 含义：每帧中数据位的位数（不含起始位、停止位、奇偶校验位）。
* 底层影响：当启用奇偶校验时，硬件可能把数据位扩展成 9 位（第 9 位用于校验），读/写时要注意库函数返回/传入的数据宽度。

### 3) `USART_StopBits`（停止位）

* 可选 0.5、1、1.5、2（STM32F1 常见设置 1 或 2）；在寄存器 `USART_CR2.STOP` 设置。
* 含义：每帧末尾的停止位个数（影响每帧持续时间），接收端用它来判断帧结束并恢复空闲状态。
* 实际影响：停位越多，每帧耗时越长，总吞吐率下降，但可提高鲁棒性（和某些设备兼容）。

### 4) `USART_Parity`（奇偶校验）

* 选项：无、偶、奇。库会设置 `USART_CR1.PCE`（启用校验）和 `USART_CR1.PS`（校验类型）。
* 含义：硬件在发送时自动产生奇偶校验位，接收端会校验并置错误标志（`PE` 等）如果校验失败。
* 注意：启用奇偶校验后，数据位长度的表述变化（比如通常用 9-bit 帧包含 8 data + 1 parity，或者 M 字段变化），读写时要用对应的库接口。

### 5) `USART_HardwareFlowControl`（硬件流控 RTS/CTS）

* 选项：None、RTS、CTS、RTS_CTS。库会设置 `USART_CR3.RTSEN` / `CTSEN`。
* 含义：启用硬件流控时使用额外的引脚（RTS/CTS）做接收/发送许可控制，适合高速或双向大量数据避免丢帧。
* 如果为 `None`（常见），不使用 RTS/CTS，只有 TX/RX 两线。

### 6) `USART_Mode`（使能接收/发送）

* `USART_Mode_Rx`：置 `USART_CR1.RE = 1`，启用接收器。
* `USART_Mode_Tx`：置 `USART_CR1.TE = 1`，启用发送器。
* `USART_Mode_Rx | USART_Mode_Tx`：同时启用（全双工）。
* 实际效果：TE/RE 控制USART是否驱动 TX、是否监测 RX。

---

# 三、寄存器对应（快速对照，便于理解“库 → 硬件”）

* 波特率：`USART_BRR`（库计算并写入）
* 控制寄存器 1：`USART_CR1`（包含 UE、RE、TE、M、PCE、PS、RXNEIE 等）
* 控制寄存器 2：`USART_CR2`（STOP 位等）
* 控制寄存器 3：`USART_CR3`（CTS/RTS、DMA、错误中断控制等）
* 状态寄存器：`USART_SR`（TXE、TC、RXNE、ORE、PE 等）
* 数据寄存器：`USART_DR`（读出为 RDR，写入为 TDR）

---

# 四、两个常见细节（经常被搞混的点）

### 1) `TXE` vs `TC`

* `TXE`（Transmit Data Register Empty）：发送数据寄存器（TDR）空，可以写入下一字节。**通常用于连续发送**，效率更高（不必等整帧完全发完）。
* `TC`（Transmission Complete）：发送完成，包含移位寄存器已空（真正的最后一位已发出）。用于在想确认“物理线上真的发完了”（例如发送完成后切换引脚模式或关闭电源）时检测。
* 你代码中使用 `while(USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET);` 等待 `TC`，这会确保字节真正发到线上（包括停止位）。如果你只是顺序发多字节，通常使用 `TXE`（等待 TDR 空）效率更高。

### 2) 空闲电平与浮空

* UART 空闲为高电平（逻辑 1）。当线悬空时可能漂移，所以若外设可能断开或长时间悬空，可在硬件上加上上拉；但如果外部总由可靠驱动（PC 的串口芯片），`IN_FLOATING` 很合适且不干扰外部驱动。

---

# 五、举个实用例子（把理论和数字对应起来）

假设：`USART1` 在 `APB2=72MHz`，要设置 `Baud = 115200`：

* `USARTDIV = fCK / (16 * Baud) = 72e6 / (16*115200) ≈ 39.0625`
* 库会把 `BRR` 写成合适的整数 + 小数编码，最终实现 115200bps。你不需要手算——库 `USART_Init` 做好了，但知道原理有助于 debug（当波特率不正确时，检查时钟/预分频是否正确）。

---

# 六、回到你的代码与常见改进建议

* 你现在等待 `TC`（发送完成）再发下一个字节：**安全但较慢**。若希望吞吐更高，使用 `TXE` 作为写下一个字节的条件（`TXE=1` 表示写入缓冲寄存器安全），或使用 DMA。
* 接收中断（`RXNE`）的处理：每收到一个字节中断一次，ISR 内应尽快读取 `DR` 将字节存入缓冲区并退出，避免阻塞中断时间过长。
* 若要支持连续高流量的收发，考虑使用环形缓冲 + DMA +流控。

---

# 七、一句话总结（方便记忆）

* `BaudRate` 决定位时长（BRR 写入）；
* `WordLength`、`StopBits`、`Parity` 决定帧格式（CR1/CR2）；
* `HardwareFlowControl` 决定是否使用 RTS/CTS（CR3）；
* `Mode` 控制 TE/RE（CR1），`AF_PP` 把 TX 交给外设驱动输出，`IN_FLOATING` 让 RX 被外部驱动读取。

---

如果你愿意，我可以：

* （A）画一张图，把 TX/RX 引脚、CR1/CR2/CR3/BRR/DR/SR 的关系画清楚；
* 或者（B）把 `USART_Init` 最终写入的寄存器位用一张表列出来（便于 debug）。

你想看哪一个？

## 实现代码分析
- 哎, 终于知道为什么这么虚了.光看初始化了,具体细节没有看...
- 仔细分析了一下实现代码,还是比较晦涩难懂的,不过也还好,明白了就很容易了.
- 首先要明确,终止输入的判断符是`/r/n`,这几乎是嵌入式行业规定的.
- 其中,`\r`英文名字是`Carriage Return(CR)`,对应`ASCII`是`0x0D`.作用是将光标移动到行首,但不换行.
- `\n`的英文名字是`Line Feed(LF)`,`ASCII`是`0x0A`,作用是将光标移动到下一行 ,但不移动列位置.
- 然后呢,我们自定义了下面两个变量.
~~~C
u8 USART::USART1_RX_BUF[200];
u16 USART::USART1_RX_STA = 0;  
~~~
- 其中,`USART1_RX_BUF`,就是用来接收电脑端的发送数据的.这里默认接收的最大值是`200`.
- `USART1_RX_STA`是我们自定义的接收(`RX`)状态(`Status`)变量.我们可以将其抽象为一个寄存器.其中,第`15`位用来判断是否接收完数据(`/r/n`),第`14`位用来判断是否接收`/r`.剩下的是十四位是用来统计输入数据的数量(所以最大接收数据量是2^14).
- 接下来,我们再分析一下流程,`MCU`到底如何跟电脑端交互的,如何收发数据的.
  - 首先,我们将程序烧录至`MCU`,`cpu`开始运行程序.
  - 然后,我们通过电脑端的串口助手,向`MCU`发送数据.数据由电脑端的`Tx`到达了`MCU`的`Rx`端.其中,`Tx`将数据转换成了系列高低电平的数字信号,有起始位,停止位等.而`Rx`中,我们将其`GPIO`初始化了,模式设为浮空输入,直接接收信号.
  - 软件端,我们使能了`usart`的中断向量,也就是配置了`USART_ITConfig(USART1, USART_IT_RXNE, ENABLE)`,每当接收到`USART_IT_RXNE`,就会发生一次中断.
  - 结合我们一开始的分析,我们知道,每捕获一个字节,`RXNE`位会置`1`,发生中断.
  - 此时直接进入我们的中断函数当中.内容如下.
~~~C
void IQRManager::usart1_handler(){
    u8 r;
    r = USART_ReceiveData(USART1);
    if((USART::USART1_RX_STA&0x8000) == 0){
        if(USART::USART1_RX_STA&0x4000){
            if(r!=0x0a) USART::USART1_RX_STA = 0;
            else USART::USART1_RX_STA |= 0x8000;
        }
        else{
            if(r == 0x0d) USART::USART1_RX_STA |= 0x4000;
            else{
                USART::USART1_RX_BUF[USART::USART1_RX_STA&0x3FFF] = r;
                USART::USART1_RX_STA++;
                if(USART::USART1_RX_STA > (USART1_REC_LEN - 1)) USART::USART1_RX_STA = 0;
            }
        }
    }
}
~~~
  - 上面写的很抽象,我还没有优化,所以可能不太好理解.
  - `r`是接收字节, 也就是`8`位二进制数.
  - `USART::USART1_RX_STA&0x8000`这个是获取`15`位,置`0`说明没有收到`\r\n`,那么进入`if`语句.
  - `USART::USART1_RX_STA&0x4000`这个则是获取第`14`位,如果置`1`,说明已经收到了`\r`.那么如果当前字节不是`0x0a`(`\n`),说明(我也不知道说明了啥,哈哈,跳过吧).如果是`\n`的话,那么就将第`15`位置`1`.
  - 然后,如果`14`位没有置`1`,则分析当前字节是不是`0x0d`(`\r`),是的话,则第`14`位置`1`,不是的话,就传入数组缓存中.
  - 其中`USART::USART1_RX_STA&0x3FFF`代表取第`14`位.从后面的`++`,可以知道,其实低`13`位代表的就是缓存数组的下标,便于我们后续输出的时候获取相关信息.
  - 上面有个跳过的地方,就是因为将`USART1_RX_STA`置`0`的话,就会丢失所有的数组下标信息,这也是我的困惑点.问了`Ai`,它说,这是有意为之.因为`\r\n`是协议规定,必须相连的.如果协议错误(比如`\r`后面未接`\n`,也就是上面那种情况),会选择清空数组,避免产生后续错误.
- 注意,上述发生的一切,都是中断发生的,最后呢,`MCU`内部缓存数组中保存了所有我们电脑端输入的数据.
- 之后,我们可以用它做很多事情,比如说,定时啊,等等.
- 不过,我们这里要做的,是将缓存数组中的数据,再发送到电脑端.这部分就是在`while`循环中做的了,我也不再细致描述了.