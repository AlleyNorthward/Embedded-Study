@auther 巷北
@time 2025.10.13 10:54
# 简介

这部分主要是说说代码问题.其实也不是代码,而是C语言的相关语法.对着写,虽然能大致明白什么意思,不过不仔细研究一下肯定也是不行的,仍需要深究一下,这样后面才不会云里雾里的.  

- [目前问题](#目前问题)
- [学习总结](#学习总结)
- [C语言问题](#C语言问题)
    - [指针](#指针)
        - [基础认识](#基础认识)
        - [进阶](#进阶)
            - [(int*) p](#intp)
			- [空指针](#空指针)
			- [函数指针](#函数指针)
			- [指针函数](#指针函数)
			- [宏定义指针](#宏定义指针)
		- [嵌入式指针应用](#嵌入式指针应用)
			- [小试牛刀](#小试牛刀)
			- [结构体指针](#结构体指针)


## 目前问题
- 宏定义后,类型问题
- 指针问题
- 变量问题(u8,u16等)
- 命名规范问题
- 函数理解
- 管脚地址问题
- C语言操作方法(~,|等)

> 似乎就这么多.等后面遇到了,再进行添加吧.下面将会解决这些问题,但是,并不是按照上面的顺序来解决的,而是按照实验所做过的顺序来的(也不一定,想怎么写就怎么写吧.不过疑问肯定都会解决的.).目前已经做到实验十了,这里先从实验四开始慢慢地分析.另外,前三个实验,有两个模版没必要说,还有一个直接操作寄存器,其实也就是对管脚地址的理解,偏向底层,这里先不分析,等后面对这些中间层的东西掌握明白后,再去回看一下就可以.  

## 学习总结
- 目前为止(实验十),这部分的内容,跟纯软件代码学习这部分不太一样.
    - 后者(纯软件)我总结的是,先理解,再去多写代码,写代码的过程中,排错并加深理解.
    - 前者(嵌入式)目前总结的是,直接跟着视频写代码,写完代码后,再去理解.因为底层内容太乏味,本来不会的话,看一遍视频,也是纯浪费时间,跟没看差别不大(可能计算机学习,更偏向于软件部分吧.).
    - 不论前者还是后者,共性是一样的,千万不要背代码,写多了就自然而然的.
- 嵌入式,先跟着视频写代码,后面理解的关键是,建立映射关系.这个函数,对应着操作硬件哪个部分,理清之后,再去看相关知识,就不会这么乏味了.了解到相关知识后呢,又会反馈到软件层面,对相关函数的使用也就更明确了.

> 总结来看:
> - 后续实验,直接跟着写代码
> - 得到硬件部分反馈后,再去ai了解
> - 然后再看视频(十分明确的话,不看视频也没关系)
> - 最后,建立函数与硬件部分映射关系,清晰地知道,操纵这个函数,实际是操纵的硬件哪个部分.

## C语言问题
关于C语言的问题,肯定是很多的,而且是需要随时整理的.有了理解就会在此写写.

### 指针
指针绝对是个大问题.因为刚学的时候,没有理解.也不是没有理解吧,是缺少实际应用,很难建立自己的认识. 那么这次,我们就来攻克它吧,因为对于嵌入式而言,确实是比较底层的了,对于相关地址的操作也是非常多地,所以不论如何,都需要有自己独立的认识.

#### 基础认识
***注意***:这部分是必须要理解的.理解之后,才能往下深入.
~~~C
int main(){
	int x = 42;
	int* p;
	p = &x;
	printf("%d, %d, %d", p, *p, x);
	return 0;
}
~~~
- 一般,我们会写`int *p`,但是我上面写的是`int* p`.这么写的优劣,我下面会专门强调.
    - 我的写法,强调的是指针类型**变量**`p`,我这里强调的`p`,是个变量,其次,才是指针类型.
    - 为什么这么强调呢?下面再来说说.
        - 普通类型变量,例如`int x`也好,其它的也罢,后续我们都会对变量`x`进行操作,非常自然.
        - 可是我自己,如果这么定义了`int *p`,我会很自然地认为`*p`是一个整体,所以非常容易搞混(比如操作`p`还是`*p`啊等等),这样不利于真正理解指针.
        - 所以,为了专门强调`p`首先是个变量,其次才是指针类型,于是,才有了上述定义方式`int* p`.
        - 这两种方式, C语言解读上没有区别,但是对于我个人的理解,却天差地别,所以还是一定要做出区分的.
    - 定义`int* p`之后,就要知道,我们操作的变量是`p`.由于它是一个指针类型,那么对于`int`类型变量`x`而言,我们不能直接`p = x`这么赋值,而是应该将`x`的地址赋值给`p`.于是,就有了`p = &x`.
    - 所以,`&x`是什么类型呢?没错,就是`int*`类型, 相同类型才能直接赋值.
    - 那么`*p`又是什么呢?这里的`*p`,其实就是解引用的的意思,获取当前地址存储的信息的.由于我们知道,`p = &x`, 那么`*p = *&x`,也就是`x`.
    - 所以说,定义时的`int*`, 代表的是指针类型变量.而我们使用`*p`,就是解引用操作.注意,解引用操作,目前只能应用于`int*`变量,而不能应用于`int`类型.
- 那么,假如,我有个变量`h`, 如果它是`int`类型,不能使用`*h`,不过可以使用`&h`取地址.而如果它是`int*`,则可以使用`*h`.
- 我自己定义的方式,就是便于理解,专门强调`p`只是一个变量,只不过是`int*`类型的,我们需要操作的仍是`p`,操作`*p`的话就是解引用,获取值.
- 这么定义(`int* p`)的坏处是什么呢?如果,有如下定义方式:`int* p, b`, 其中,`p`是指针类型变量, 而`b`是`int`类型变量,所以这么做会产生混淆.
> **总结**:`int* p`是指针类型变量.对于`int x`,`&x`也是`int*`类型变量.所以可以直接如下赋值`p = &x`.而`*p`是解引用,相当于`*&x`,也就直接等于`x`.所以,`*`是取值,而`&`是取地址.

> 定义时的`int* p`的`*`和使用时的`*p`的`*`,含义不同.前者为声明中的一部分,后者为解引用操作.

> 最终,`int* p`, 我们可以取其值,使用`*p`, 对于`int x`,我们可以取其地址,也就是`&x`.这也就是`int*`与`int`之间转换的方式.

> 对于`int* p`, 我们不仅可以对它取值,也可以取地址(`p`变量本身地址).也就是`*p`,`&p`一起使用.而对于`int x`, 我们只能取地址, 也就是`&x`,而不能取值,`*x', 因为`*`取值操作,只能对指针使用.
#### 进阶
进阶这部分慢慢弄吧,也没必要专门搜集,意义不大.我就将嵌入式中遇到的一些指针操作放进来,便于理解吧.不过前面的,我还是会放一些我自己曾经不太理解的问题.

##### (int*)p

下面代码是我现改的.请问有错误吗?
~~~C
int main(){
	int x = 42;
	int a;
	(int*) a;
	a = &x;
	printf("%d, %d, %d", a, *a, &x);
	return 0;
}
~~~
**答案**:有错误,编译器不通过.
- `a`是`int`类型,虽然有`(int*)`强制转化,但是无论如何,我们也无法将`a`强制转化,它仍然是`int`类型.不过我们可以给其赋值,也就是如下操作:
~~~C
int main(){
	int x = 42;
	int a;
	int* p = (int*) a;
	p = &x;
	printf("%d, %d, %d", p, *p, &x);
	return 0;
}
~~~
- 需要注意,这样会有潜在风险,`int`为四个字节,而指针为八字节,所以不建议这么操作.但是在`keil`,`ARM`芯片中,是32位,都是四字节,不会产生问题,所以标准库中,会有很多类似操作.举下面这个例子:
~~~C
int main(){
	int x = 42;
	int a_int = 0x1234;     
	int* p = (int*)a_int;   
	printf("%p\n", (void*)p);
}
~~~
- 还是解释一下吧.`a_int`,不论其是几进制,都是`int`类型.所以`0x1234`虽然是十六进制,但是仍然为`int`类型,我们不能直接赋值给指针.所以,我们可以将其强制转化为指针类型变量,这样就能直接赋值了.后面的`%p`是为了输出十六进制.`(void*)`是消除警告,知道这么操作就行.

**另**
上面的例子,是将整型,强制转化为整型指针,还有种情况是指针的强制类型转化.在课本`P181`页.我这里就简单说说,能看明白就看明白,看不明白也没事,实际操作时遇到,产生疑问后再去解决,印象更加深刻.

~~~C
int main(){
    int n = 3, * p;
    double* q;
    void* gp1, * gp2;
    gp1 = &n;
    p = (int*) gp1;
    printf("%d, %d", *p, *gp1);
	q = (double*) gp1;
    return 0;
}
~~~
- 如上代码,`gp1`是`void*`类型,`p`赋值时,类型不匹配,可以强制转化一下,然后赋值.
- 后面输出的`*gp1`就不对了.因为前面也说了,`(int*) gp1`,是赋值操作,并不会将`gp1`强制转化,它`仍然为(void*)`类型.
- 后面的`q`的赋值也不对.因为`void*`虽然是通用指针,但是当它指向`int`类型数据后,只能强制转化为`(int*)`,而不能转化为`(double*)`.虽然不会报错,但是输出结果不符合预期.
- 还有其它可能,比如`int`型指针强制转换为`double`型指针.但是这个做似乎意义不大.因为`int*`指向的是`int`数据,转换为`double*`,仍然无法访问.
> 总结来看,指针之间的强制转化,需要循序指针类型与普通类型相匹配,否则转化没有意义.

##### 空指针
代码示例如下
- 示例1
~~~C
int f(...){
	int* p, n = 3;
	*p = 2;
	...
}
~~~
这个肯定是错误的.因为指针`p`并没有指向合法变量,就直接赋值.
- 示例2
~~~C
void swap(int* p, int* q){
	int t = *p;
	*p = *q;
	*q = t;
}

int main(){
	int p, n = 3;
	swap(&p, &n);
}
~~~
这样做是不安全的.因为`p`未赋值,所以会造成意想不到的情况.如果直接传入`p`,很明显的错误,就是类型不匹配.

##### 函数指针

- 刚开始学的时候,确实不懂,毕竟也缺少实际应用.写了那么多`python`之后,这部分变得很明确了.`python`高级设计模式,看了很多,跟着`manim`也学了很多.突然领悟的地方是,看着个类,传入了个类名参数.当时思考为什么传入类名,而不是这个类的实例化对象呢?因为这样可以自主确定该类的生命周期,需要使用的时候,可以类名()来实例化.  
- 可是这跟函数指针有什么关系呢?  
- 很有关系.因为在`python`中,将函数,类等等赋予变量,很容易,毕竟无需类型要求.可是在`C/C++`中,这种操作就不行.我们想将函数,类赋予某变量,或者想延缓其生命周期,仍需赋予某变量,那么对于这个变量而言,是什么类型呢?函数指针类型.这也是其存在的意义.
- 当前,`C/C++`的设计方面,涉及的很少,所以函数指针在平时刷题时,也都很少用到(其实也没用过).但是有了`python`的实际应用,也知道了它的意义,所以理解起来也就更加轻松了.

~~~C
int foo() { return 42; }

int (*p)();  // 函数指针
p = foo;     // 合法
int result = p(); // 调用函数
~~~

- 上面是`ai`的例子,知道就行.等后续需要的时候,再专门详细研究就可以.
- `int (*p)` 和 `int* p` 含义是一样的.而`int (*p)()`这样才代表函数指针.
- 下面再贴上一个简单应用吧.

~~~C
int max(int a, int b){
    return (a > b) ? a : b;
}
int min(int a, int b){
    return (a < b) ? a : b;
}
int compute_extreme(int a, int b, int (*func)(int, int)){
    return func(a, b);
}
int main(){
    int a = 3;
    int b = 4;

    int c = compute_extreme(a, b, max);
    int d = compute_extreme(a, b, min);

    printf("%d, %d", c, d);

    return 0;
}
~~~
- `compute_extreme()`函数,有很多实现方式.比如,可以传入一个`flag`,根据其值,判断调用`min()`还是`max()`.不过这样的问题,需要写判断语句,相对于这个而言,不够简洁.
- 当然,也可以直接调用函数,不用再定义`compute_extreme`.因为我这个函数十分简单,可以不用定义.但如果当项目十分庞大,需要复杂的`comopute_extreme`的时候,函数传参的意义十分有必要的.
- 这个例子也能很明显地看出来生命周期的意义.我们将`max`或者`min`作为参数传入,可以随时通过`func()`调用,不用担心其他问题.

##### 指针函数

这部分任重道远,先放个例子,后面实际应用的时候再说吧.
~~~C
#include <stdio.h>

int* getPointerToInt() {
    static int x = 10; // 注意：必须是静态变量，否则返回局部变量地址非法
    return &x;
}

int main() {
    int *p = getPointerToInt(); // 调用指针函数
    printf("%d\n", *p);         // 输出 10
    return 0;
}
~~~

嗨,我以为什么呢...就是返回值是个指针.比如想返回数组,就需要返回值为指针类型.相较于函数指针,难度也不是很大.

##### 宏定义指针
因为在嵌入式应用中,其库都是将指针通过宏的方式定义好的,并不是传统的定义方式,所以这里专门来分析一下.
~~~C
#define MY_RCC_BASE				0x1234
#define Test_RCC                (*(int*)MY_RCC_BASE)
int main(){
    printf("%d", Test_RCC); // 不行,卡住.
    /*
        原因:
            MY_RCC_BASE,确实就是一个值,0x1234,转化为十进制也好,二进制也罢,都是等价的.
        而且宏定义的时候,并没有定义类型,所以这一步没有任何问题.
            如果添加强制类型转换,则对于(int*)MY_RCC_BASE而言,就是在告诉C语言,0x1234不
        再是一个普通的数了,它现在是一个地址.
            而(*(int*)MY_RCC_BASE)就是在获取当前地址下的值.
            所以main中,我试图访问这个数,但是访问不了.原因就是这个地址是电脑中真实存在的
        地址,也就是在告诉操作系统:我想去访问内存地址 0x00001234 处的 4 个字节,并把
        它解释成一个 int.
            但是程序只能访问 操作系统分配的内存区域(进程空间),0x1234是我们抽象出来的,
        一般情况下,操作系统会介入终止访问,所以才无法输出.
            但是这行代码,确实很好的模拟了嵌入式库中各种定义,也能更好地明白.
    */
    return 0;
}
~~~
为了更加真实地模拟,我们就用计算机真实存在的地址来举例.
~~~C
int fake_reg = 1234;
#define MY_RCC_BASE             &fake_reg
#define Test_RCC                (*(int*)MY_RCC_BASE)
int main(){
    printf("%d, %p, %p", Test_RCC, &Test_RCC, MY_RCC_BASE); 
    return 0;
    //输出结果:
    // 1234, 0000000000403010, 0000000000403010
}
~~~
- 我用`fake_reg`来抽象模拟.
- `(int*)`强制类型转化其实多余了,因为`&fake_reg`本身就是`int*`类型(前面说过了).但是没有去掉,就是为了模拟.
- 从输出结果来看,Test_RCC就是一个普通变量,不是一个指针变量.如果下面这种定义方式,就是指针变量了.
~~~C
#define Test_RCC			((int*)MY_RCC_BASE)
~~~
- 因为`*`就是取值的意思,给地址取值,赋值给某变量,那么这个变量其实就是对应的是这个值.而该变量的地址,与值的地址相同.所以从`printf()`也能看到,`&Test_RCC = MY_RCC_BASE`.
- 这样我后面嵌入式应用中,可能就说错了.
- 为了便于理解,我下面再贴一下`Test_RCC`为指针的情况.
~~~C
int fake_reg = 1234;
#define MY_RCC_BASE             &fake_reg
#define Test_RCC                ((int*)MY_RCC_BASE)
int main(){
    printf("%d, %p, %p", *Test_RCC, Test_RCC, MY_RCC_BASE); 
    return 0;
    // 输出同上
}
~~~
- 这样似乎就能区分了.
- 还有一个问题是,我发现无法对`Test_RCC`取值(`&Test_RCC`),这样会漂红.
- 这里其实就是宏定义指针跟普通指针定义之间的区别了.宏定义,其实就是直接替换(比如`*Test_RCC`替换后就是`*((int*)MY_RCC_BASE)`),并没有显式的左值(其实也就是没有实际的地址空间),所以不能直接取值.
- 上面说的指针,可以取值和取地址操作,而宏定义的指针,只能取值,而不能取地址.

#### 嵌入式指针应用
有了上面的基础后,这部分就比较容易理解了.这里还是举例子,实际应用的例子.不过是慢慢积累的,而不是一次性总结完的.

##### 小试牛刀
先来看看下面的宏定义
~~~C
#define GPIOA_BASE 0x40020000 
#define GPIOA_ODR (*(volatile unsigned int*)(GPIOA_BASE + 0x14))
~~~
有何区别?
- 对于`GPIOA_BASE`而言,它就仅仅代表的是`GPIO`的基地址,仅此而已,无法读写相关内容.
	- 需要注意的是,`stm32`是`32`位的,在`C`中,经常用`8`位`16`进制来表示其`32`位`2`进制数.
	- 另外,我们之前也专门强调过了,数据类型与进制数无关.所以`0x40020000`可以转换为对应二进制数,也可以转换为对应十进制数,含义都是一模一样的.只不过习惯上用十六进制来表示,因为确实容易读取.
- 结合前面的**宏定义指针**,很明确,`GPIOA_ODR`就是一个普通变量,其值就是`GPIOA_BASE + 0x14`下的值.其地址也就是`GPIOA_BASE + 0x14`.
- `GPIOA_ODR`本身并没有地址,这也是它与普通指针的区别.
##### 结构体指针
代码示例
~~~C
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR; 
} GPIO_TypeDef;

#define GPIOA ((GPIO_TypeDef*)RCC_BASE)
~~~
- 这里的GPIOA是一个结构体指针.
- 想对结构体内部变量进行读取操作,可以直接`GPIOA -> MODER = ?`操作.相当于`(*GPIOA).MODER = ?`.
- 注意,上面的`?`是值,还是地址?这是非常关键的.`->`其实就是访问变量`MODER`,所以`GPIOA->MODER`本身就是一个变量,并不是指针.
- `?`这里对应的其实是值.因为我们有数据类型(`uint32_t`),其实也就代表它有地址了.并且其地址,是基于`GPIOA`的地址获取的.比如,`MODER`的地址可能为`RCC_BASE + 0x20`,具体的要看芯片内部地址的划分了.
- 不过从`C`中怎么抽象划分地址的,我还没仔细看库,所以知道`GPIOA`是结构体指针,指向基地址`RCC_BASE`,其结构体内部的变量,已经按照基地址,分配好了本身的地址.
> 有了这些先决条件后,再去分析库,就会好很多了.