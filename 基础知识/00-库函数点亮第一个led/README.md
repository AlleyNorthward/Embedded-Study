@auther 巷北  
@time 2025.10.7 23:02  
# 简介
昨天跟着敲了一遍, 运行很成功, 但是一些基本的原理还是不太清楚. 今天又回顾了一下底层, 领悟了一下原理, 感觉也算可以了.当然,相关知识欠缺很多, 后续回补也是必然的.  
不过在库函数使用上, 还有些很乱, 所以打算这这里梳理一下架构, 明白了函数的使用,访问,查找,等等,后续学习会非常有帮助.当然,一股脑地死磕下去,对着抄代码,虽然能运行起来,但是缺少个人理解,自己不会查找,也很难走远的.

- [基本步骤](#基本步骤)
- [对应函数](#对应函数)
    - [first拆解](#first拆解)
    - [second拆解](#second拆解)
    - [third拆解](#third拆解)
    - [fourth拆解](#fourth拆解)
- [led原理](#led原理)

---

# 基本步骤

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\00基本步骤.svg" alt="基本步骤图片" title = "基本步骤">
    </a>
</p>

- 现在还没有具体函数,我就单纯说说,等到后面有函数,再细致说说.`APB2`是总线名词,需要知道.使能二字,对应的是禁止.使能就是开启`APB2`总线上的时钟,这样我们才能有权利,控制`GPIO`的管脚,来进行输入输出操作.如果不使能,就无法操作.所以这一步是必须的.
- 初始化`GPIO`,就是配置一下`GPIO`,比如模式啊,速度啊,什么的.
- `led`灯是个二极管,其中,正极(三角形尾部)接3.3v,负极(尖端)接`GPIO`某管脚.负极为低电平,才能点亮`led`,所以这里说的设置低电平,是`GPIO`某管脚对`led`负极的输入.更加细致的解读如下:当`GPIO`管脚输出低电平时,`led`负极被拉低,形成阳极(3.3V) → 阴极(0V)电压差,`led`导通发光。

# 对应函数

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\01对应函数.svg" alt="对应函数图片" title = "对应函数">
    </a>
</p>

- 很长,所以我们就单独拆开每个函数分析,这里就宏观上说说.
- 这是库函数,一定有非常非常多的函数.深入学习`manim`后,已经对库的学习有个人独特认识, 我也不再多说什么了.
- 这些函数肯定不是一上来就知道的.看教程得来的.但是教程并没有说函数怎么用,内部的参数还是要自己查找的.那么怎么找呢?
- 函数查找,需要从`.h`文件中去找,而不是`.c`文件中找.因为`.h`中优先定义了函数,但是没实现,`.c`中则是函数的实现,所以会非常长.我们总能在`.h`中找到教程中的函数,然后定位到`.c`文件中的函数即可查看源代码.
- 函数中都会有参数,但是传什么参数呢?下方一般会有`assert`来判断参数是否合法,我们可以溯源定位一下,查看传参类型,这样就能找到我们需要的参数了.
- 此时基本问题就解决了,但是我们需要设计自己的结构,所以也不单单是实现这几个函数就完事.具体结构问题后面再说,这里就不涉及.

## first拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\02first拆解.svg" alt="first拆解图片" title = "first拆解">
    </a>
</p>

- `RCC`代表复位与时钟控制模块
- `APB2Periph`代表`APB2`总线上的外设
- `ClockCmd`代表打开或关闭时钟(使能或禁止)
- 有了上面的解释,这个函数就很好明白了->控制`APB2`总线上外设始终的开启或关闭
- 第一个参数,看名字就知道,可能需要添加`GPIO`的某些东西.但是具体也不知道是什么,此时我们可以溯源看一下.进入之后,看到了这个语句`assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph))`,嗯,再溯源看一下`IS_RCC_APB2_PERIPH`,或许就能知道些什么.查看之后,果真,找到了`GPIOB`的管脚地址宏定义`#define RCC_APB2Periph_GPIOB ((uint32_t)0x00000008)`,那么`GPIOB`是什么呢?
- `GPIOB`的`B`,是其端口(`port`)号,每组有16个引脚(0~15),`B`代表的就是`PB`的这个`B`.这部分不是凭空来的.因为原理图中,`led0`是由`PB5`管脚控制的,所以我们就需要找`RCC_APB2Periph_GPIOB`而不是其他的.
- 对于`led1`而言,其被`PE5`管脚控制,所以需要找的端口为`RCC_APB2Periph_GPIOE`, 自然而言.
- 第二个参数,其实就是控制的使能和禁止.溯源一下发现,参数为`DISABLE`与`ENABLE`,所以为了使能时钟,需要传参`ENABLE`.
- 最后,宏观上来看,这个函数并不是对所有GPIO管脚进行使能时钟,而是只针对某一端口(比如`GPIOB`或者`GPIOE`)

## second拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\03second拆解.svg" alt="second拆解图片" title = "second拆解">
    </a>
</p>

- 函数名很清晰, `GPIO`初始化(回过头来看, 也只是对某`GPIO`端口进行初始化)
- 第一个参数,回溯发现,传入的是端口指针(这样就不需要解引用了, 直接传就行)
- 第二个参数, 溯源后发现竟然是结构体指针.这样的话,我们找到对应的结构体,看看内部参数,然后在`led.c`文件中,显式地定义一个结构体变量,并且给内部参数赋值.赋值之后,就可以传参了.别忘了传入的是引用(地址).
- 但是问题是,结构体内部参数,如何赋值呢?或者说,是什么类型的呢?
- 还是按照基本步骤,溯源`GPIO_Init()`,找到`assert_param`,一个一个看就行
- 结构体参数,有个50hz的,说的是一般都选这个,有一个是选择`GPIO_Mode_AF_PP`这个模式,下面两个是复用的,不用到,这个和左边的是输出的,没有 特殊说明就选这个.虽然不理解,但是目前来看,知道就行.这个模式名叫做推挽输出,能输出高电平和低电平,是最常用的输出模式.ai了一下,就不放在这里了.

## third拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\04third拆解.svg" alt="third拆解图片" title = "third拆解">
    </a>
</p>

- 这个函数名, 就是设置某端口管脚输出的电平的. 这个函数是设置为高电平.注意,它只管输出的,输入不管的.
- 第一个参数跟`second`的第一个参数传的是一样的.其实就是传的GPIO的某端口.比如,我的二极管对应端口为`PB`,那么这里传参就是`GPIOB`,代表的是`B`端口.
- 第二个参数代表的是引脚.其实在`second`中也有,只不过是在接口体中赋的值.比如我想找`PB5`,端口`B`的第五个引脚, 那么这里就传入对应引脚就好了.`Pin`就是代表的第几个引脚.

## fourth拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\05fourth拆解.svg" alt="fourth拆解图片" title = "fourth拆解">
    </a>
</p>

- 跟`third`类似,这里不多说了
- 设置`GPIO`管脚输出为低电平.

> 似乎大体就这么多. 写完后也明白清晰了很多.
> 关键点有下面这些
> - 弄清基本原理
> - 搞明白需要哪些函数,以及该函数的作用是什么
> - 学会查找函数参数,对于有特殊含义的参数,需要清楚所选择参数的含义

> 其他的似乎就没有了, 编程相关的东西太熟悉了,也不多说了.

# led原理

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\assets\架构拆解\led原理图.png" alt="led原理图片" title = "led原理图">
    </a>
</p>

- 其实普中里面有图,但是我不想用,想用自己`multisim`模拟出来的图.
- 结构说明
    - 左侧`vcc`3.3v是电源通电端口, 也就是用户自主输入端.
    - 电阻`R1`为保护电阻.
    - `LED1`就是发光二极管.左侧为阳极,右侧为阴极.
    - `S1`模拟设置`GPIO`的高低电平转换器.
    - 最右侧就是模拟`GPIO`的输出电平了.
- 二极管阴极设为低电平就会发光.
- 二极管发光原理:由于阳极始终接在`vcc`中,所以一直为高电平.阴极输入高电平时,`LED1`内部相对电压为0(3.3 - 3.3),此时不发光.阴极输入为低电平时,相对电压为3.3v,此时就发光了.
- 基本原理:
    - `STM32` 的 `CPU` `GPIO` `USART` `ADC` `TIM` `SPI`等外设,都需要时钟信号才能工作.而这些时钟都由`RCC`模块统一分配与控制.所以一上来需要使能时钟.
    - `GPIO`的初始化, 需要选择对应的模式,速度,管脚等.其中模式有很多,详细在架构拆解中有说明.这里需要推挽输出,来决定输出的高低电平.
    - 接下来就是设置高低电平了.
- `GPIO`详细说明
    - `GPIO`有很多端口(`port`),比如`PA`, `PB`, `PC`等等.对应的代码中,就是`GPIOA`, `GPIOB`, `GPIOC`等等.每个端口都有16个引脚(0~15),所以我们在硬件上,经常看到`PB1`,`PE3`等描述,代表的就是`B`端口的第一引脚与`E`端口的第三引脚.
    - `GPIO`有很多模式,目前,需要知道的模式就是推挽输出,可以设置高低电平.还有其它的很多模式,等后续用到后,再来分析.
    - `GPIO`的所有管脚, 在`f103`系列,似乎都在`APB2`总线上.
    - 本实验模拟的`led`处于`PB5`上.
- 软件(代码)分析:
    - 第一步,我们一定要开启时钟.对应函数`RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)`.函数名是调节`APB2`总线上外设时钟.上面说了,`GPIO`所有管脚似乎都在`APB2`总线上,所以这个函数以后会经常用到.
        - 第一个参数是选择外设.我们需要的是`B`端口,所以找到对应参数传入即可.
        - 第二个参数是使能或禁止.
    - 第二步,初始化`GPIO`,对应函数为`void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)`.
        - 第一个参数是选择哪个端口.
        - 第二个参数是接收一个结构体,内部有三个参数,分别为速度(一般选50hz),管脚(`pin`,我们需要的是5),模式(推挽模式,对应为`GPIO_Mode_Out_PP`).
    - 第三步,设置初始电平为高电平,避免一上来就开启.对应函数为`void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)`
        - 第一个参数也是选择哪个端口,与上面的那个第一个参数一致.
        - 第二个则是找到对应管脚.也与上面类似,只不过上面管脚参数封装到了结构体里.
    - 接下来,我们将上面功能,封装到一个函数中,名字设为`LED_INIT(void)`,这样方便我们在`main`中调用.
    - 最后,在`main`中调用`LED_INIT(void)`,并且调节低电平,就能发光了.低电平对于函数为`void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)`,其参数与`SetBits`函数一致,
- 软件部分结束后的操作就不说了, 关于代码的设计, 还需要多看看别人写的代码, 然后了解一下基本模式, 再去多练习写写.
