@author 巷北  
@time 2025.10.17 19:34
# 简介
距离买板子已经过去了`10`天了,从刚开始的一点不懂,到如今稍微入了门,感觉还不错.这部分内容回归十天前第一次点亮`led`代码的解析,`C`语言最原始的方法点亮操作小灯的方法--直接操作寄存器.能分析清楚这一点,对硬件方面的理解,深入了非常多.缺少对硬件的理解,单纯从代码角度,很难理解其实现原理.

- [寄存器拆解](#寄存器拆解)
- [GPIO寄存器](#gpio寄存器)
    - [GPIO配置寄存器](#gpio配置寄存器)
    - [GPIO位设置/复位寄存器](#gpio位设置复位寄存器)
- [软件部分运算符](#软件部分运算符)
- [点亮led代码解析](#点亮led代码解析)

## 寄存器拆解
- `stm32`的寄存器,都是`32`比特位的.
- 这是为了与整体相协调(总线数据传输,`cpu`运算都是`32`位)
- 但这并不意味着所有寄存器的每一位都会用上.比如,有的时候只用低`16`位,高`16`位不会用.
- 寄存器并不一定以一位为单位分隔,也可能以多位分隔(比如,每`4`位为一整体,这样`32`位可拆成`8`组,每组管理对应的操作.)
- 所以,寄存器可以通过每位,代表`0`或`1`(或者高低电平),也可以通过多位,管理更多信息内容(比如两位一组,可以用`00 01 10 11`这类,代表其它信息)
- 寄存器的每一位,每一组,都包含独特的信息.而`cpu`内部有多个寄存器,每个寄存器都有自己特定功能,管理数据分发(详细可见上个文件夹`cpu`数据分发部分),然后通过总线(`32`位)传输数据,运送到目的外设寄存器,外设根据寄存器信息,做出对应动作,从而实现对应功能.

## GPIO寄存器
### GPIO配置寄存器
- `GPIO`的配置寄存器,名字有`GPIOx_CRL`和`GPIOx_CRH`.
- `GPIO`有多个端口,每个端口固定`Pin`脚`0~15`个.
- 寄存器的配置信息,需要`4`位表示,而每个寄存器是`32`位,这样导致一个寄存器不够用,需要两个寄存器.
- 所以`CRL`和`CRH`含义是`Config-Register-Low`和`Config-Register-High`,分别配置低位(`Pin`脚`0~7`)和高位(`Pin`脚`8~15`).
- 配置寄存器的`4`位,又会被拆分成`[1:0]`和`[3:2]`,其中`[1:0]`位,表示`4`位中的两个低位(`[1:0]`),名称是`MOOD[1:0]`,两个高位(`[3:2]`),名称是`CNF[1:0]`.`4`位中的两组的排列组合,可以表示`GPIO`的运行模式(也就是我们选择推挽,输出速度等的那个配置).具体信息可以从手册中查找.
> **总结**:
> - 两寄存器(`GPIOx_CRL`与`GPIOx_CRH`)用来存储`16`个`GPIO PIN`脚的全部配置信息.
> - 每一个`Pin`脚需要`4`位来存储所有信息.
> - 其中的`4`位,又拆分为`[1:0]`和`[3:2]`这两对,共同组合成了一个`Pin`的配置信息.
### GPIO位设置/复位寄存器
- 这个寄存器的名字是`GPIO_BSRR`,其中`BSRR`是`Bit Set/Reset Register`的缩写.
- 这个寄存器分为了两大组,`[15:0]`和`[31:16]`,对应名称分别为`BSy`(`[15:0]`,`Set`位),`BRy`(`[31:16]`,`Reset`位)
- 所以经常表示`BSRR`的低位和高位,分别代表设置`Pin`脚某位或者重置`Pin`脚某位.
- `Set`位置`1`,输出高电平,`Reset`位置`1`,输出低电平.
- 需要与`ODR`寄存器区分.这里的`BSRR`一般是初始化用的.不过`ODR`我不清楚,这里不作描述.

## 软件部分运算符
- `|,^,&,~`这些运算符就不说了,就是将`32`位二进制数对齐后,做对应操作即可.
- 有的寄存器运算是`|=`或者是`&=`,有的则直接`=`,为什么呢?如何区分呢?
    - 这就要强调寄存器的特性了.有只读寄存器,只写寄存器,可读可写寄存器.
    - 对于只读寄存器,我们无法写信息,所以对其使用赋等操作没有意义,因为无法写.
    - 对于只写寄存器(比如`BSRR`),没有读的概念,只能写,所以运算符用`=`即可.我们不需要关心其初始值,写`1`生效,写`0`不生效,写完后自动清除,等待下一次写入.
    - 对于可读可写寄存器(比如`ORD`),就有初始值的概念了,这样我们需要用到`|=`,`&=`语法,避免对其它位产生影响.
- 有时候,我们会看到有些值(或掩码)采用`|`进行连接,然后直接赋等,没有问题,只写寄存器的话,相当于直接打开开关了.
- 对了,还有`<<`和`>>`这两个运算符.分别代表的是左移和右移.比如`1<<3`,就是将`1`左移三位,如果用`8`位二进制表示,也就是`00001000`.而这个`00001000`,就是之前说的掩码.
- 所以,以前疑惑掩码是怎么来的,其实就是`ST`公司自定的,划分好了寄存器的每一位,每一位都有其作用,当我们想操作该位时,只需要`<<`或`>>`这俩运算符,或者直接根据运算符计算所得的掩码,进行相应的计算,就可以达到操作该寄存器的目的.
- 注意,`<<`这个运算符包括左右两个部分,右边就代表移位数,很明确,那么左边只能代表`0`或`1`吗?
- 并不是.如果只分析寄存器的某一位,那么只有`<<`左侧就只能是`0`或`1`.可是,我们上面也举了例子,如果寄存器多位变成一组,很明显就超出了`0`和`1`这个范围.所以寄存器两位一组的话,左侧可以取`0 1 2 3`,即`00 01 10 11`.四位一组的话,就有`0 1 2 3 4 5 6 7...15`.
- 所以左侧可以取`32`位内的任何值,不过具体取值,需要结合实际情况来看,而不是盲目取值.

## 点亮`led`代码解析
~~~C
#define PERIPH_BASE      ((unsigned int)0x40000000)
	
#define APB2PERIPH_BASE  (PERIPH_BASE + 0x00010000)

#define GPIOB_BASE       (APB2PERIPH_BASE + 0x0C00)

#define GPIOB_CRL 	 	 *(unsigned int*)(GPIOB_BASE+0x00)
#define GPIOB_CRH 	 	 *(unsigned int*)(GPIOB_BASE+0x04)
#define GPIOB_IDR 	 	 *(unsigned int*)(GPIOB_BASE+0x08)
#define GPIOB_ODR 	 	 *(unsigned int*)(GPIOB_BASE+0x0C)
#define GPIOB_BSRR 	 	 *(unsigned int*)(GPIOB_BASE+0x10)
#define GPIOB_BRR 	 	 *(unsigned int*)(GPIOB_BASE+0x14)
#define GPIOB_LCKR 	 	 *(unsigned int*)(GPIOB_BASE+0x18)

#define AHBPERIPH_BASE   (PERIPH_BASE + 0x20000)

#define RCC_BASE 		 (AHBPERIPH_BASE + 0x1000)
#define RCC_APB2ENR 	 *(unsigned int*)(RCC_BASE+0x18)

typedef unsigned int u32;   

void SystemInit(void)
{
	
}

void delay(u32 i)
{
	while(i--);
}

int main()
{
	RCC_APB2ENR |= 1<<3;
	GPIOB_CRL &= ~( 0x0F<< (4*5));
	GPIOB_CRL |= (3<<4*5);
	GPIOB_BSRR=(1<<(16+5));
	while(1)
	{
		GPIOB_BSRR=(1<<(16+5));
		delay(0xFFFFF);
		GPIOB_BSRR=(1<<(5));
		delay(0xFFFFF);
	}
}
~~~
- 从上图可知,宏定义中,有的`BASE`有的不是指针类型.我觉得目的是,先确定基地址后,再通过基地址偏移确定外设地址.有了外设地址之后,再通过强制类型转化为指针,然后再取值.所有带有`BASE`的不一定是地址.但经过强制类型转化后的,是地址.
- 由寄存器宏可知,都是`*`(取值)之后的值.这些值存储着各种各样的信息.上面寄存器中,我们也解释了.
- 关于这些宏的相关地址/值的信息,都是根据手册来的.当前,我们先不分析如何查找它们(主要是手册地址部分还看不懂,慢慢来,后面懂了如何查找之后再分析吧)
- 我们再来看看`main`中逻辑部分吧.
    - `RCC_APB2ENR`代指的是`APB2`总线时钟复位使能寄存器.该寄存器可读写,通过或运算,将该寄存器第三比特位赋值为`1`.推测该比特位含义,应该是对应`APB2`总线的`B`端口(推测而言,没有实际论证).
    - 下一句是`GPIOB_CRL &= ~(0x0F<< (4*5))`,其中`&= ~`.为什么会这么操作呢?
        - 因为一般`<<`这种操作,默认补`0`,而不是补`1`,所以需要取反操作,使得其它位(一般是`0`)取反变为`1`,这样`&=`操作后,其它位不变(仍为初始值).
        - 对于上面的运算,需要从内往外读.`(4*5)`代表的是,每`4`位一组,获取第`5`组,其实就是代表操作`PB5`,也就是`Pin5`.
        - 接下来需要赋值,我们想设为`0`,代表将该组(`4`位)设为初始值(`0`).`0x0F`就是代表`1111`,取反后经过`&=`运算就变为`0000`了
    - 下一句是`GPIOB_CRL |= (3<<4*5)`.`4*5`还是确定`Pin5`管脚,`3`是什么呢?
        - `3`代表二进制数`11`.`4`位二进制数的话就是`0011`.
        - 上面拆解`GPIOx_CRL`寄存器的时候说了,该`4`位二进制数,分为`[1:0]`和`[3:2]`,可以看到,`[1:0]`位是`11`,`[3:2]`代表的是`00`.对应的是`50HZ`和推挽输出(推测的,没有实际看手册.),所以赋值为`3`,就是确定了这几个配置模式.
    - 然后是`GPIOB_BSRR = (1<<(16+5))`.`BSRR`说了,是只写寄存器,所以直接采用`=`,而没有`|=`和`&=`.由于是初始化阶段,所以需要输出低电平,需要操作高位,也就需要通过`16+5`,代表操作高位的低5位,并设为`1`(使能).(不过`led`低电平是亮,所以我觉得这里设为高电平比较好)
    - 循环中就是比较简单了,一会亮,一会不亮.并且采用了延时函数.