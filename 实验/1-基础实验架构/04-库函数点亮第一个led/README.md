@auther 巷北  
@time 2025.10.7 23:02  
# 简介
昨天跟着敲了一遍, 运行很成功, 但是一些基本的原理还是不太清楚. 今天又回顾了一下底层, 领悟了一下原理, 感觉也算可以了.当然,相关知识欠缺很多, 后续回补也是必然的.  
不过在库函数使用上, 还有些很乱, 所以打算这这里梳理一下架构, 明白了函数的使用,访问,查找,等等,后续学习会非常有帮助.当然,一股脑地死磕下去,对着抄代码,虽然能运行起来,但是缺少个人理解,自己不会查找,也很难走远的.

- [基本步骤](#基本步骤)
- [对应函数](#对应函数)
    - [first拆解](#first拆解)
    - [second拆解](#second拆解)
    - [third拆解](#third拆解)


# 基本步骤

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\out\架构拆解\00基本步骤.svg" alt="基本步骤图片" title = "基本步骤">
    </a>
</p>

- 现在还没有具体函数,我就单纯说说,等到后面有函数,再细致说说.`APB2`是总线名词,需要知道.使能二字,对应的是禁止.使能就是开启`APB2`总线上的时钟,这样我们才能有权利,控制`GPIO`的管脚,来进行输入输出操作.如果不使能,就无法操作.所以这一步是必须的.
- 初始化`GPIO`,就是配置一下`GPIO`,比如模式啊,速度啊,什么的.
- `led`灯是个二极管,其中,正极(三角形尾部)接3.3v,负极(尖端)接`GPIO`某管脚.负极为低电平,才能点亮`led`,所以这里说的设置低电平,是`GPIO`某管脚对`led`负极的输入.更加细致的解读如下:当`GPIO`管脚输出低电平时,`led`负极被拉低,形成阳极(3.3V) → 阴极(0V)电压差,`led`导通发光。

# 对应函数

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\out\架构拆解\01对应函数.svg" alt="对应函数图片" title = "对应函数">
    </a>
</p>

- 很长,所以我们就单独拆开每个函数分析,这里就宏观上说说.
- 这是库函数,一定有非常非常多的函数.深入学习`manim`后,也已经对免息那个对象十分明确了, 对库的学习有个人独特认识, 我也不再多说什么了.
- 这些函数肯定不是一上来就知道的.看教程得来的.但是教程并没有说函数怎么用,内部的参数还是要自己查找的.那么怎么找呢?
- 函数查找,需要从`.h`文件中去找,而不是`.c`文件中找.因为`.h`中优先定义了函数,但是没实现,`.c`中则是函数的实现,所以会非常长.我们总能在`.h`中找到教程中的函数,然后定位到`.c`文件中的函数即可查看源代码.
- 函数中都会有参数,但是传什么参数呢?下方一般会有`assert`来判断参数是否合法,我们可以溯源定位一下,查看传参类型,这样就能找到我们需要的参数了.
- 此时基本问题就解决了,但是我们需要设计自己的结构,所以也不单单是实现这几个函数就完事.具体结构问题后面再说,这里就不涉及.

## first拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\out\架构拆解\02first拆解.svg" alt="first拆解图片" title = "first拆解">
    </a>
</p>

- `RCC`代表复位与时钟控制模块
- `APB2Periph`代表`APB2`总线上的外设
- `ClockCmd`代表打开或关闭时钟(使能或禁止)
- 有了上面的解释,这个函数就很好明白了->控制`APB2`总线上外设始终的开启或关闭
- 第一个参数,看名字就知道,可能需要添加`GPIO`的某些东西.但是具体也不知道是什么,此时我们可以溯源看一下.进入之后,看到了这个语句`assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph))`,嗯,再溯源看一下`IS_RCC_APB2_PERIPH`,或许就能知道些什么.查看之后,果真,找到了`GPIOB`的管脚地址宏定义`#define RCC_APB2Periph_GPIOB ((uint32_t)0x00000008)`,那么`GPIOB`是什么呢?
- `GPIOB`的`B`,是其端口(`port`)号,每组有16个引脚(0~15),`B`代表的就是`PB`的这个`B`.这部分不是凭空来的.因为原理图中,`led0`是由`PB5`管脚控制的,所以我们就需要找`RCC_APB2Periph_GPIOB`而不是其他的.
- 对于`led1`而言,其被`PE5`管脚控制,所以需要找的端口为`RCC_APB2Periph_GPIOE`, 自然而言.
- 第二个参数,其实就是控制的使能和禁止.溯源一下发现,参数为`DISABLE`与`ENABLE`,所以为了使能时钟,需要传参`ENABLE`.
- 最后,宏观上来看,这个函数并不是对所有GPIO管脚进行使能时钟,而是只针对某一端口(比如`GPIOB`或者`GPIOE`)

## second拆解

<p align="center">
    <a href = "https://github.com" target="_blank">
        <img src=".\out\架构拆解\03second拆解.svg" alt="second拆解图片" title = "second拆解">
    </a>
</p>

- 函数名很清晰, `GPIO`初始化(回过头来看, 也只是对某`GPIO`端口进行初始化)
- 第一个参数,回溯发现,传入的是端口指针(这样就不需要解引用了, 直接传就行)
- 第二个参数, 溯源后发现竟然是结构体指针.这样的话,我们找到对应的结构体,看看内部参数,然后在`led.c`文件中,显式地定义一个结构体变量,并且给内部参数赋值.赋值之后,就可以传参了.别忘了传入的是引用(地址).
- 但是问题是,结构体内部参数,如何赋值呢?或者说,是什么类型的呢?
- 还是按照基本步骤,溯源`GPIO_Init()`,找到`assert_param`,一个一个看就行
- 结构体参数,有个选50hz的,说的是一般都选,有一个是选择`GPIO_Mode_AF_PP`这个模式,下面两个是复用的,不用到,这个和左边的是输出的,没有 特殊说明就选这个.虽然不理解,但是目前来看,知道就行.这个模式名叫做推挽输出,能输出高电平和低电平,是最常用的输出模式.ai了一下,就不放在这里了.